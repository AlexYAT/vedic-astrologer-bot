# Безопасное чтение из users.db

## Ответ на вопрос

**Нет, чтение из `users.db` в режиме только для чтения не поломает базу данных.**

SQLite поддерживает:
- ✅ **Множественные читатели одновременно** — безопасно
- ✅ **Чтение во время записи** — читатели не блокируют писателей
- ✅ **Параллельный доступ** — несколько процессов могут читать одновременно

## Рекомендации для внешних программ

### 1. Используйте режим только для чтения (рекомендуется)

```python
import sqlite3
from pathlib import Path

db_path = Path("users.db")
db_uri = f"file:{db_path}?mode=ro"  # ro = read-only
conn = sqlite3.connect(db_uri, uri=True)
```

**Преимущества:**
- Гарантия, что случайная запись не повредит БД
- Явное указание намерения (только чтение)
- Защита от ошибок в коде

### 2. Простое чтение (если уверены, что не пишете)

```python
conn = sqlite3.connect("users.db")
# Просто не вызывайте conn.execute() с INSERT/UPDATE/DELETE
```

### 3. Используйте транзакции для консистентности

```python
conn = sqlite3.connect("users.db")
conn.row_factory = sqlite3.Row  # Удобный доступ к колонкам

cursor = conn.execute("SELECT * FROM users WHERE telegram_id = ?", (user_id,))
row = cursor.fetchone()
# Данные будут консистентными на момент начала SELECT
```

## Что может пойти не так?

### ❌ Проблемы (если делать неправильно):

1. **Попытка записи в режиме `ro`** — получите ошибку `sqlite3.OperationalError: attempt to write a readonly database`
2. **Открытие БД с `check_same_thread=False` при записи** — может вызвать проблемы (но для чтения безопасно)
3. **Чтение во время миграции БД** — может увидеть неконсистентное состояние (но не повредит БД)

### ✅ Безопасно:

- Читать из нескольких процессов одновременно
- Читать во время работы бота
- Использовать `SELECT` запросы
- Анализировать данные для статистики

## Пример использования

См. `scripts/read_db_example.py` для примеров безопасного чтения.

## Структура таблиц

Основные таблицы:
- `users` — данные пользователей (telegram_id, birth_date, birth_time, birth_place, mode, pro_until)
- `user_requests` — история запросов
- `surveys`, `survey_runs`, `survey_answers` — опросы
- `user_threads` — thread_id для OpenAI Assistants

## Примечания

- Бот использует стандартное подключение без специальных блокировок
- SQLite автоматически управляет блокировками на уровне файла
- Читатели не блокируют друг друга
- Писатель блокирует только на время записи (обычно миллисекунды)
